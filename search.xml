<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>迷宫求解</title>
      <link href="/2019/03/07/mi-gong-qiu-jie/"/>
      <url>/2019/03/07/mi-gong-qiu-jie/</url>
      
        <content type="html"><![CDATA[<pre><code>#include &lt;math.h&gt;#include &lt;stack&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;windows.h&gt;#define MARTIX 10#define NO_ACCESS 0#define ACCESS 1#define ACCESSED -1using namespace std;int map[MARTIX][MARTIX] = {//   0  1  2  3  4  5  6  7  8  9    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, // 0    {0, 0, 1, 0, 1, 1, 1, 1, 1, 0}, // 1    {0, 1, 0, 0, 1, 0, 1, 0, 1, 0}, // 2    {0, 1, 1, 1, 1, 0, 0, 1, 1, 0}, // 3    {0, 1, 0, 0, 1, 1, 1, 1, 0, 0}, // 4    {0, 1, 1, 1, 0, 1, 0, 1, 1, 0}, // 5    {0, 1, 0, 1, 1, 1, 0, 0, 1, 0}, // 6    {0, 1, 0, 0, 0, 0, 0, 1, 1, 0}, // 7    {0, 1, 1, 1, 1, 1, 1, 1, 1, 0}, // 8    {0, 0, 0, 0, 0, 0, 0, 0, 1, 0}  // 9};enum Direct{    UP,    DOWN,    LEFT,    RIGHT};typedef struct _POS{    int x;    int y;} POS;struct Player{    int x;    int y;} player;stack&lt;POS&gt; his_pos_stack;void gotoxy(int x, int y){    COORD coord;    coord.X = (short)x;    coord.Y = (short)y;    HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE);    //SetConsoleTextAttribute(handle,FOREGROUND_INTENSITY | BACKGROUND_BLUE);    SetConsoleTextAttribute(handle, BACKGROUND_INTENSITY | BACKGROUND_GREEN);    SetConsoleCursorPosition(handle, coord);}void gotoEnd(){    gotoxy(0, MARTIX + 1);}void InitMap(int (*agr)[10]){    int i, j;    for (i = 0; i &lt; 10; i++)    {        for (j = 0; j &lt; 10; j++)        {            gotoxy(j * 2, i);            if (agr[i][j] == 1)            {                printf(&quot;?&quot;);            }            else            {                printf(&quot;?&quot;);            }        }        printf(&quot;\n&quot;);    }}void drawPlayer(){    gotoxy(player.x * 2, player.y);    printf(&quot;?&quot;);    gotoEnd();}void SetPlayerPos(Player *mPlayer, int x, int y){    mPlayer-&gt;x = x;    mPlayer-&gt;y = y;}int GetPositionStatus(int (*args)[10], int x, int y){    return args[y][x];}void SetPositionStatus(int (*args)[10], int x, int y, int status){    args[y][x] = status;}void back(){    gotoxy(player.x * 2, player.y);    printf(&quot;?&quot;);    gotoEnd();    his_pos_stack.pop();    POS last_pos = his_pos_stack.top();    player.x = last_pos.x;    player.y = last_pos.y;    drawPlayer();}void go(int x, int y){    gotoxy(player.x * 2, player.y);    printf(&quot;?&quot;);    gotoEnd();    SetPositionStatus(map, x, y, ACCESSED);    SetPlayerPos(&amp;player, x, y);    drawPlayer();    POS new_pos;    new_pos.x = x;    new_pos.y = y;    his_pos_stack.push(new_pos);}void move(){    POS last_pos = his_pos_stack.top();    POS cur_pos[4];    int length = -1;    if (GetPositionStatus(map, last_pos.x, last_pos.y - 1) == ACCESS)    {        cur_pos[++length].x = last_pos.x;        cur_pos[length].y = last_pos.y - 1;    }    if (GetPositionStatus(map, last_pos.x, last_pos.y + 1) == ACCESS)    {        cur_pos[++length].x = last_pos.x;        cur_pos[length].y = last_pos.y + 1;    }    if (GetPositionStatus(map, last_pos.x - 1, last_pos.y) == ACCESS)    {        cur_pos[++length].x = last_pos.x - 1;        cur_pos[length].y = last_pos.y;    }    if (GetPositionStatus(map, last_pos.x + 1, last_pos.y) == ACCESS)    {        cur_pos[++length].x = last_pos.x + 1;        cur_pos[length].y = last_pos.y;    }    if (length &gt; -1)    {        int index = rand() % (length + 1);        go(cur_pos[index].x, cur_pos[index].y);    }    else    {        back();    }}void InitPos(int x, int y){    SetPlayerPos(&amp;player, x, y);    SetPositionStatus(map, x, y, ACCESSED);    POS init_pos;    init_pos.x = x;    init_pos.y = x;    his_pos_stack.push(init_pos);}void init(){    InitMap(map);    InitPos(1, 1);    drawPlayer();}int main(int argc, char const *argv[]){    srand((unsigned int)time(NULL));    init();    while (1)    {        Sleep(1000);        move();        if (player.x == 8 &amp;&amp; player.y == 9)        {            printf(&quot;winer\n&quot;);            break;        }    }    system(&quot;pause&quot;);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 算法 </tag>
            
            <tag> 迷宫求解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>表达式求值</title>
      <link href="/2019/03/07/biao-da-shi-qiu-zhi/"/>
      <url>/2019/03/07/biao-da-shi-qiu-zhi/</url>
      
        <content type="html"><![CDATA[<pre><code>#include &lt;stack&gt;#include &lt;stdio.h&gt;#define MAX 0x7FFFFFFF#define MIN 0xFFFFFFFFusing namespace std;// 操作数栈stack&lt;int&gt; sOPND;// 操作符栈stack&lt;char&gt; sOPTR;// 操作符集合表char OPTR[] = {&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;, &#39;(&#39;, &#39;)&#39;, &#39;#&#39;, &#39;\0&#39;};// 操作符优先级表char PrecedeR[][7] = {    //+    -    *    /    (    )    #    {&#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;},  // +    {&#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;},  // -    {&#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;},  // *    {&#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;},  // /    {&#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;=&#39;, &#39; &#39;},  // (    {&#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;, &#39;&gt;&#39;, &#39; &#39;, &#39;&gt;&#39;, &#39;&gt;&#39;},  // )    {&#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39;&lt;&#39;, &#39; &#39;, &#39;=&#39;}}; // #// 判断是否在操作符集合 返回所在集合索引int IsInOP(char op){    int i;    for (i = 0; OPTR[i] != &#39;\0&#39;; ++i)    {        if (op == OPTR[i])        {            // 返回索引            return i;        }    }    return MIN;}// 判断两个操作符的优先级char Precede(char ch1, char ch2){    if (IsInOP(ch1) != -1 &amp;&amp; IsInOP(ch2) != -1)    {        return PrecedeR[IsInOP(ch1)][IsInOP(ch2)];    }    return &#39; &#39;;}// 判断是否是操作数int IsDigit(char ch){    if (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)    {        return 1;    }    return 0;}// 执行运算操作int Operate(char theta, int a, int b){    switch (theta)    {    case &#39;+&#39;:        return a + b;    case &#39;-&#39;:        return a - b;    case &#39;*&#39;:        return a * b;    case &#39;/&#39;:        return a / b;    default:        return MAX;    }}int calculator(const char *str){    int position = 0, num = 0;    sOPTR.push(&#39;#&#39;);    while (str[position] != &#39;#&#39; || sOPTR.top() != &#39;#&#39;)    {        char ch = str[position];        if (IsDigit(ch))        {            num = num * 10 + (ch - &#39;0&#39;);            position++;        }        else        {            if (num != 0)            {                // 是操作数则进操作数栈                sOPND.push(num);                // 清零                num = 0;            }            switch (Precede(sOPTR.top(), ch))            {            case &#39;&lt;&#39;:                // 期待符优先级高于操作符栈顶元素则期待符入栈，读头指向下一个期待符                sOPTR.push(ch);                position++;                break;            case &#39;&gt;&#39;:            {                // 期待符优先级低于操作符栈顶元素则操作符栈顶元素出栈                // 操作数栈弹出两个操作数 进行相应的算数符号运算并将运算结果压入操作数栈                int b = sOPND.top();                sOPND.pop();                int a = sOPND.top();                sOPND.pop();                sOPND.push(Operate(sOPTR.top(), a, b));                sOPTR.pop();                break;            }            case &#39;=&#39;:                // 期待符优先级等于操作符栈顶元素则操作符栈顶元素出栈，读头指向下一个期待符                sOPTR.pop();                position++;                break;            }        }    }    if (!sOPTR.empty())    {        return sOPND.top();    }    return MAX;}int main(int argc, char const *argv[]){    char str[80];    while (1)    {        printf(&quot;请输入算数表达式\n&quot;);        gets(str);        sprintf(str, &quot;%s%c&quot;, str, &#39;#&#39;);        int result = calculator(str);        printf(&quot;计算结果:%d\n&quot;, result);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 算法 </tag>
            
            <tag> 表达式求值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo搭建指南</title>
      <link href="/2019/03/07/hexo-da-jian-zhi-nan/"/>
      <url>/2019/03/07/hexo-da-jian-zhi-nan/</url>
      
        <content type="html"><![CDATA[<ul><li><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><pre><code>  yum -y install git  git config --global user.name &quot;ilixiaofu&quot;// github用户名  git config --global user.email  &quot;ilixiaofu@qq.com&quot;// github注册邮箱</code></pre></li><li><h2 id="安装NVM"><a href="#安装NVM" class="headerlink" title="安装NVM"></a>安装NVM</h2><pre><code>  git clone https://github.com/creationix/nvm.git  source nvm/nvm.sh</code></pre></li><li><h2 id="安装Nodejs"><a href="#安装Nodejs" class="headerlink" title="安装Nodejs"></a>安装Nodejs</h2><pre><code>  nvm install stable  添加Node环境变量  vim /etc/profile  在底部添加 PATH 变量  export PATH=$PATH:/usr/local/node/bin  source /etc/profile</code></pre></li><li><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><pre><code>  npm install -g hexo-cli</code></pre></li><li><h2 id="Hexo常用命令"><a href="#Hexo常用命令" class="headerlink" title="Hexo常用命令"></a>Hexo常用命令</h2><pre><code>  hexo init &lt;文件名&gt;  hexo g == hexo generate       hexo d == hexo deploy  hexo s == hexo server  hexo n == hexo new  hexo clean</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
